<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Luca&#39;s Trove</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Anirudh Katoch" />
  <meta name="description" content="Anirudh Katoch&#39;s personal website." />
  <meta name="keywords" content="Katoch, Anirudh, Job, Software, Engineer" />






<meta name="generator" content="Hugo 0.30.2" />


<link rel="canonical" href="http://luca-spopo.github.io/project/" />
<link href="http://luca-spopo.github.io/project/index.xml" rel="alternate" type="application/rss+xml" title="Luca&#39;s Trove" />
  <link href="http://luca-spopo.github.io/project/index.xml" rel="feed" type="application/rss+xml" title="Luca&#39;s Trove" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">

<link id="favicon_link" rel="icon" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
 
<script type="text/javascript">
  var logosource = '/img/logos/logo'+Math.floor(1 +  7 *Math.random())+'.png'
  document.getElementById("favicon_link").href = logosource
</script>




<link href="/dist/even.min.css?v=2.6.5" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">

<meta property="og:title" content="Projects" />
<meta property="og:description" content="Anirudh Katoch&#39;s personal website." />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://luca-spopo.github.io/project/" />



<meta property="og:updated_time" content="2016-10-10T00:00:00&#43;00:00"/>










<meta itemprop="name" content="Projects">
<meta itemprop="description" content="Anirudh Katoch&#39;s personal website.">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Projects"/>
<meta name="twitter:description" content="Anirudh Katoch&#39;s personal website."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

<style type="text/css">
  .post-tag a {
    border: 1px solid #cb5b4d;
    border-radius: 4px;
    padding-left: 2px;
    padding-right: 2px;
    color: #cb5b4d;
    margin: 2px;
  }
  .post-tag {
    display: inline;
  }
</style>
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar" style="position: static">
  <div class="mobile-header-logo">
    <a href="/" class="logo">
              <img class="logoImage" style="height:20px; margin-right: 5px;"></img>Luca&#39;s Trove</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu" style="background: none">
  <ul class="mobile-menu-list">
    <a href="/about/">
        <li class="mobile-menu-item">About me</li>
      </a><a href="/portfolio/">
        <li class="mobile-menu-item">Portfolio</li>
      </a><a href="/project/">
        <li class="mobile-menu-item">Projects</li>
      </a><a href="/blog/">
        <li class="mobile-menu-item">Blogs</li>
      </a><a href="/tutorial/">
        <li class="mobile-menu-item">Tutorials</li>
      </a>
    <img src="/img/chiyo-chichi.png" id="slideout-chiyochichi"> 
    <script>
      {
      var chiyo_chichi_float = document.getElementById("slideout-chiyochichi")
      var callback;
      callback = function() { chiyo_chichi_float.style.paddingTop = (10+Math.floor(10*Math.sin(Date.now()/1000)))+"px" ; requestAnimationFrame(callback) }
      requestAnimationFrame(callback)
      }
    </script>
  </ul>
</nav>
  <header id="header" class="header" style="padding: 0; float: none;">
        <nav class="site-navbar" style="background-color: white; height: 40px;box-shadow: 0px 1px 2px #c05b4d; z-index: 100; float: none; margin-bottom: 3px">
  <div class="logo-wrapper-" style="white-space: nowrap;margin-left: 10%;">
    <b style="font-size:20px;font-family: 'Josefin Sans','Helvetica Neue',Helvetica,Arial;">
    <a href="/" class="logo-" style="display: inline-block;white-space: normal;width:300px;">
      <img class="logoImage" style="height:25px; margin-right: 15px; margin-bottom: 5px;"></img>Luca&#39;s Trove</a>
  <ul id="menu" class="menu" style="white-space: normal;display: inline-block;margin-top: 3px;">
    <li class="menu-item" style="list-syle-type: none">
        <a style="margin-left: 10px; margin-right : 10px;font-size:15px" class="menu-item-link" href="/about/">About me</a>
      </li><li class="menu-item" style="list-syle-type: none">
        <a style="margin-left: 10px; margin-right : 10px;font-size:15px" class="menu-item-link" href="/portfolio/">Portfolio</a>
      </li><li class="menu-item" style="list-syle-type: none">
        <a style="margin-left: 10px; margin-right : 10px;font-size:15px" class="menu-item-link" href="/project/">Projects</a>
      </li><li class="menu-item" style="list-syle-type: none">
        <a style="margin-left: 10px; margin-right : 10px;font-size:15px" class="menu-item-link" href="/blog/">Blogs</a>
      </li><li class="menu-item" style="list-syle-type: none">
        <a style="margin-left: 10px; margin-right : 10px;font-size:15px" class="menu-item-link" href="/tutorial/">Tutorials</a>
      </li>
  </ul>
  </b>
  </div>
</nav>
  </header>
  <div class="container" id="mobile-panel">
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          
	<div id="searchbar-div">
		<div><input class="button" type="button" onclick="location.reload()"></div>
		<div><input id="searchbar" type="text" onkeyup="searchDocs()" placeholder="Search posts..."></div>
	</div>
	<style>
	#spacebar-div div {
		display: table-cell;
		background-color: #000000;
		width: 100%;
	}
	#searchbar-div {
		width: 70%;
		margin-top: 20px;
		display: table;
	}
	#searchbar-div div .button {
		background:url('/css/chronological.png');
		opacity: 0.7;
		background-repeat: no-repeat;
		width:40px;
		white-space: nowrap;
		position: absolute;
		height:40px;
		border: 0;
	}
	#searchbar {
	    background-image: url('/css/searchicon.png');
	    background-position: 10px 12px;
	    background-repeat: no-repeat;
	    padding: 12px 20px 12px 40px;
	    width: 100%;
	    margin-left: 50px;
	    border: 1px solid #c05b4d;
	}
	</style>
  <section id="project" class="project">
    
        <article class="post" id="Ash">
  <header class="post-header">
    <h1 class="post-title"><a class="post-link" href="/project/ash/">Ash</a></h1>
    <div class="post-meta">
      <span class="post-time"> October 10, 2016 </span>
      
      <div class="post-tag">
          <a href="/tags/lua/">Lua</a><a href="/tags/mta/">MTA</a><a href="/tags/ui/">UI</a>
        </div>
      
    </div>
  </header>
  
  <div class="post-content">
    <div class="post-summary">
      Ash is a closed source UI library for MTA implemented in pure Lua. It provides its own window management system, own event system, own input system and own tweening system. It has a foreign interface so cool that it was forked as its own open source project called bakaGaijin.
    </div>
    <div class="read-more">
      <a href="/project/ash/" class="read-more-link">Read more..</a>
    </div>
  </div>
</article>
    
        <article class="post" id="Hewlett Packard Enterprise">
  <header class="post-header">
    <h1 class="post-title"><a class="post-link" href="/project/hpe/">Hewlett Packard Enterprise</a></h1>
    <div class="post-meta">
      <span class="post-time"> July 5, 2016 </span>
      
      <div class="post-tag">
          <a href="/tags/javascript/">Javascript</a><a href="/tags/java/">Java</a><a href="/tags/bot/">Bot</a>
        </div>
      
    </div>
  </header>
  
  <div class="post-content">
    <div class="post-summary">
      <p>My summer internship at HP resulted in the creation of a clever and simple system to tackle a complex problem (Under construction)</p>

<p></p>
    </div>
    <div class="read-more">
      <a href="/project/hpe/" class="read-more-link">Read more..</a>
    </div>
  </div>
</article>
    
        <article class="post" id="Procedural Generation">
  <header class="post-header">
    <h1 class="post-title"><a class="post-link" href="/project/proc-play/">Procedural Generation</a></h1>
    <div class="post-meta">
      <span class="post-time"> July 3, 2016 </span>
      
      
      
    </div>
  </header>
  
  <div class="post-content">
    <div class="post-summary">
      <p>Procedural level and art generation for tiled video games using noise, upscaling, L-systems and cellular automata.</p>
    </div>
    <div class="read-more">
      <a href="/project/proc-play/" class="read-more-link">Read more..</a>
    </div>
  </div>
</article>
    
        <article class="post" id="bakaGaijin">
  <header class="post-header">
    <h1 class="post-title"><a class="post-link" href="/project/bakagaijin/">bakaGaijin</a></h1>
    <div class="post-meta">
      <span class="post-time"> May 1, 2016 </span>
      
      
      
    </div>
  </header>
  
  <div class="post-content">
    <div class="post-summary">
      bakaGaijin is an open source (MIT License) library that allows seamless cross resource communication across Lua virtual machines in MTA. It allows you to pass functions, tables (by reference), and such complex types that the C interface is not actually capable of sending. It is implemented in pure Lua.
    </div>
    <div class="read-more">
      <a href="/project/bakagaijin/" class="read-more-link">Read more..</a>
    </div>
  </div>
</article>
    
        <article class="post" id="FOSSEE">
  <header class="post-header">
    <h1 class="post-title"><a class="post-link" href="/project/fossee/">FOSSEE</a></h1>
    <div class="post-meta">
      <span class="post-time"> January 3, 2016 </span>
      
      <div class="post-tag">
          <a href="/tags/testing/">Testing</a><a href="/tags/bash/">Bash</a><a href="/tags/scilab/">Scilab</a><a href="/tags/matlab/">MATLAB</a><a href="/tags/c/">C</a><a href="/tags/open-source/">Open Source</a><a href="/tags/vm/">VM</a>
        </div>
      
    </div>
  </header>
  
  <div class="post-content">
    <div class="post-summary">
      <p>I had the wonderful opportunity to intern at IIT Bombay to help develop the Image Processing Toolbox for Scilab, a free software developed by French company Scilab Enterprises. I got this opportunity as a member of FOSSEE (Free Open Source Software For Education), an initiative by IIT Bombay to make available open source equivalents of proprietary academic software.</p>

<p></p>
    </div>
    <div class="read-more">
      <a href="/project/fossee/" class="read-more-link">Read more..</a>
    </div>
  </div>
</article>
    
  </section>
    <script src='/js/elasticlunr.min.js'></script>
	<script type="text/javascript">
   	var searchIndex = elasticlunr(function () {
	    this.addField('title');
	    this.addField('tags');
	    this.addField('content');
	    this.setRef('title');
	});
	
        searchIndex.addDoc({
        	"title" : "Ash",
        	"tags" : "Lua MTA UI",
        	"content" : " Ash is a framework/library for MTA that gives you the most flexible and most beautiful UI. Ash does not only provide a beautiful GUI, it also aims to wrap over all other UI. For now that includes GUI, keyboard input and mouse input.\nThe Problem Multitheft Auto is an open source modification of Rockstar\u0026rsquo;s very successful (and old) game Grand Theft Auto: San Andreas. It adds support for multiplayer (GTA:SA is originally single player only), and lets the server hosting the game change every aspect of the game at run time through Lua scripts that interact with hooks provided by the engine.\nThis means we can add functionalities that did not originally exist in the game.\nWe can add a clan system that lets clan leaders set clan roles, kick members, maybe drop a \u0026ldquo;Message of the day\u0026rdquo;. We can add our own chatbox to let different clients chat with each other. We can let them own particular vehicles, or houses, and provide them with a UI to buy/sell such assets. The possibilities are endless.\nTo design the UI that would be required with such functionalities, MTA uses and provides CEGUI. It provides Lua with functions that let it create CEGUI components and add listeners to them, and control their life cycle.\nCEGUI components look something like this:\nThey do not look bad, but very often they do not match up with the theme of the rest of the UI. Imagine using that GUI while the bottom right of your screen looks like this:\nAs a result, user experience suffers, and most importantly, my scripts don\u0026rsquo;t look as beautiful as they can.\nHistory CEGUI was made as a very flexible and skin-able GUI Library, but it is implemented in C++, Lua only gets the hooks that MTA exposes to it. MTA only ships with one theme of CEGUI, and as such there is no way for a server to change the theme on a client. An analogy would be MTA\u0026rsquo;s CEGUI being a Chrome/Firefox/Edge native library, while the server can only send out Javascript (Lua in this case)\nHow would the JS community cope with this? They would use a canvas to draw their own GUI one primitive rectangle at a time, and implement the entire library in pure javascript. That is the approach I decided to follow, and the result was Ash. MTA exposes some very primitive directX drawing functions, and Ash takes it from there.\nBefore I started work on Ash, the first question I asked was: \u0026ldquo;Has this been done already?\u0026rdquo;. Reinventing the wheel is very educational, but I needed Ash for my production server so I could not afford to waste time. The answer is yes, There exists a library called dxGUI which aimed to replace CEGUI. I forked it and inspected its source code. While the code itself was written beautifully, the project did not dream big. It simply emulated CEGUI along with (what I perceive as) its pitfalls. It succeeded at being a pure Lua implementation, but the only new features it added were themes. These themes were actually static images. The renderer would take parts of these static images to construct its components. As a result, different \u0026ldquo;themes\u0026rdquo; were just reskins of the exact same shape using different textures.\nThe Solution CEGUI (left) vs Ash (right), don\u0026rsquo;t mind the typo\nAsh is very flexible and skin-able. I insist that it\u0026rsquo;s even more flexible and skinable than CEGUI. Right now it has Panes, Input boxes, Labels, ImageBoxes, Tabs, and some other components. It\u0026rsquo;s missing some basic components like check boxes, radio boxes, scroll bars etc. But the beauty is that they can be implemented by just dragging component files into a particular folder. Adding new themes is also as simple as adding files to a directory. How big would such files be? Just 50-100 lines of code. Ash already provides all the window management, the components just have to maintain their own state, add event listeners, and conform to specification.\nAsh was not just designed just to succeed CEGUI, it was designed to give all the power possible to the Lua programmer.\nAsh is different. Ash themes are not images, they are lua files. They provide a function that is called whenever the view is to be updated, and provide hooks to let the theme have very fine control over exactly how it is rendered. It even lets the theme have it\u0026rsquo;s own state information so that it can implement animations and the likes independent of whether or not the component itself is aware of it.\nCrowd-sourcing, Logical Independence, and Decoupling Another thing Ash does better is that it decouples components from their renderers. If you were to add an implementation of radio boxes to Ash, then you would create one file to define the component (state information and events about the radio box itself, such as it\u0026rsquo;s coordinates, visibility, alpha, onClick, checked etc), and then add a separate function to the theme which would deal with how it is rendered (As a square, or as a circle, or perhaps even some sort of slider).\nIn effect, person A can make a component called RadioBox, and add the functions for it to the default theme. Person B could decide to change what a RadioBox looks like, and create some other theme with some other functions that implement the rendering differently.\nI expect Ash to have a lot of community created content when it gets its public release.\nOne problem with this approach is that a component may not be implemented in the particular theme that is being used. I have good news: Ash themes use prototype inheritance and if the current theme does not have functions to render a component, it falls back to a theme higher up in the prototype chain. The default theme is usually on top of the prototype chain (I expect the person who made the component to have made a vanilla version of the renderer and added it to the default theme at least.)\nAsh assumes that all renderers and themes are untrusted, and as such the global environment is sanitized and read-only, so that renderers do not have access to anything they can use to aid the forces of evil.\nStateful Renderers I use the word \u0026ldquo;Theme\u0026rdquo;. The system is best explained through code. This is what a theme looks like in Ash.\n--A theme called \u0026quot;Foobar\u0026quot; local Foobar = {} do local thistheme = Foobar; local name = \u0026quot;Foobar\u0026quot; AshTheme.addTheme(thistheme, name) thistheme.ashName = \u0026quot;AshTheme: \u0026quot;..name thistheme.meta = {__index = thistheme, __tostring = gettype} setmetatable(thistheme, AshTheme.Default.meta) --At this point we have set up the prototype chain, this theme looks up to Default --Now some easy to edit parameters regarding font, colours and the like thistheme.bgcolor = tocolor( 58, 69, 77 ) thistheme.fgcolor = tocolor(194,94,78) thistheme.fgcolor2 = tocolor(194,94,78) thistheme.fgcolor3 = tocolor(94,94,178) thistheme.color_danger = tocolor(200,100,100) thistheme.color_go = tocolor(94,134,78) thistheme.textcolor = tocolor( 200, 200, 100 ) thistheme.textcolorhead = tocolor( 230, 120, 100 ) thistheme.font1 = \u0026quot;default\u0026quot; thistheme.font1b = \u0026quot;default-bold\u0026quot; thistheme.font2 = dxCreateFont(\u0026quot;themes/Foobar/light.otf\u0026quot;, 12) thistheme.font2b = dxCreateFont(\u0026quot;themes/Foobar/bold.otf\u0026quot;, 12) --init contains functions that (if existent) should be called when a component is first rendered thistheme.init = {} local init = thistheme.init --clear contains functions that should be called (if they exist) when component's theme is changed or it is removed thistheme.clear = {} local clear = thistheme.clear --This function is called by Ash before a component named Test is rendered for the first time function init.Test(self, themecontext) --self is a READ ONLY version of the Test component, themes are for representing the data, not changing the data --themecontext is an empty table that is available to the renderer as long as the component is to be rendered. It is discarded if the theme is changed or component is destroyed. --This function is only visited once, so we can do heavy tasks like creating a texture themecontext.myTexture = Texture.new(\u0026quot;bla.jpg\u0026quot;); themecontext.height = 0 end function thistheme.Test(self, themecontext) --This function is called every time the component needs to be redrawn if themecontext.height \u0026lt; self.height then --Increase themecontext.height every frame until it reaches self.height themecontext.height = math.min(themecontext.height*1.01, self.height) end --Draw a rectangle who's height is taken from themecontext.height dxDrawRectangle( 0, 0, self.width, themecontext.height, self.fgcolor or thistheme.fgcolor) dxDrawText(\u0026quot;Hello\u0026quot;, 0, 0, 100, 100, 0, themecontext.myFont) end function thistheme.Test2(self, themecontext) --Do nothing end end  In the following lines, \u0026ldquo;renderer\u0026rdquo; refers to thistheme.Test, init.Test and clear.Test\nThe code above declares a Theme called Foobar, which implements renderers for components called Test and Test2. The renderer can maintain state information in a table called themecontext which is maintained and passed as a parameter to the renderer. A read-only version of the component is also passed to the renderer as \u0026ldquo;self\u0026rdquo; to let it poll data (like text or checked status) from it.\nThis particular theme draws Test as an animated box with hello written on the top left. The box is animated because it starts as a thin line and then turns into a rectangle over time. Its height increases over time. This behavior is not defined by the component, but by the theme. The theme maintains its own state and functions to implement the animation. Such a thing is not possible in CEGUI or dxGUI.\nNote that I may not have implemented all the things that I have mentioned here. Notably, the clear function for renderers is not called (Because there is no theme yet that uses it).\nAlso note that thistheme.Test increases themecontext.height by a factor of 1.01 every render. In the current implementation, every render is every frame, but the actual rate at which the renderer is called is unspecified. I am working on a system to cache the last drawn image and keep it until an update is propagated by any children, and in that case the renderer would be called less often. The correct way to implement a \u0026ldquo;height increasing window\u0026rdquo; as shown here would rely on polling the system time every render. Perhaps the time elapsed since last call can also be provided as a parameter in future versions.\nthistheme.Test2 explicitly has a renderer that does nothing. If such a component is using this theme, it would not show up on the screen at all.\nIf this theme is used to render thistheme.Test3, which is not implemented, it would fall back to the Default theme, which this theme inherits from. Another theme can further inherit from this Foobar theme, that\u0026rsquo;s the usual way prototype inheritance works.\nTheme is not a global property Every component has a \u0026ldquo;theme\u0026rdquo; property which is either null, or points to a theme. If it\u0026rsquo;s theme is null, then the theme is inherited from the parent, or grandparent, or somewhere up the prototype chain. (Just as themes inherit from themes, component instances inherit themes from their parents in the display tree)\nThus, you can mix and match themes. You can have a window using ThemeXYZ, with 3 input boxes each of which employs a different theme. It would not look good, probably, but it\u0026rsquo;s possible. Moreover, themes automatically and dynamically change (unless they are explicitly specified) if the display tree is changed, with components inheriting themes from their new parents.\nComponents use OOP I have used the word \u0026ldquo;component\u0026rdquo;, let\u0026rsquo;s see what implementing a component looks like.\n--Defines a component called Label Components.Label = {} local Label = Components.Label do local thisclass = Label; --Making the component inherit from AshElement gives it useful functions like addEventHandler etc. --bakaKill was used by bakaGaijin, another library I made. thisclass.meta = {__index = thisclass, __tostring = gettype, __bakaKill = AshElement.destroy}; thisclass.type = \u0026quot;Label\u0026quot; --Constructor function thisclass.new(x, y, width, height, text, color, font) --Making the instance a subclass from AshElement gives it basic properties like --x, y, id etc local self = AshElement.new(x, y, width, height); setmetatable(self, thisclass.meta); self.text = text; self.theme.textcolor = color; self.theme.font = font; return self; end end  And that\u0026rsquo;s it. We now have a label. Want to give it an event handler for clicking? Here is some code from the Button component\nButton.mouse_move_listener = function(self, eventname, eventargs) --snip snip end function Button.new(x, y, width, height) local self = AshElement.new(x, y, width, height); setmetatable(self, Button.meta); self:addEventListener(\u0026quot;mouse_move\u0026quot;, Button.mouse_move_listener) self:addEventListener(\u0026quot;mouse_click\u0026quot;, Button.mouse_move_listener) return self; end  Ash\u0026rsquo;s own Event System Who is dispatching these events? Ash is. Ash has it\u0026rsquo;s own event system. MTA does provide it\u0026rsquo;s own event system, but it is not flexible about the order in which the events are bubbled up or down by the listeners, or even if they are bubbled up first or bubbled down first. Ash implements its own event system in pure Lua without relying on MTA. Ash\u0026rsquo;s event system lets us give it an iterator that would select which children should be bubbled to, and which should not.\nIt gets better. On every step of the bubble, a component can choose to edit/terminate the event from bubbling further. A window may get an \u0026ldquo;Z was pressed\u0026rdquo; event from its parent. It could then look up if Z is set as a hotkey for \u0026ldquo;close\u0026rdquo; (suppose it was). It could then EDIT the event to carry the data \u0026ldquo;Window was closed\u0026rdquo; instead of \u0026ldquo;Z was pressed\u0026rdquo;. This provides a layer of abstraction to the children that are listening for events\nNot just GUI I mentioned that \u0026ldquo;Z was pressed\u0026rdquo; could come as an event to a component. Indeed, Ash is not a GUI replacement, it is a UI replacement. It detects every keypress, and no keypress filters through it without its consent.\nMTA\u0026rsquo;s input boxes had a problem long ago: You may have \u0026ldquo;Z\u0026rdquo; bound to \u0026ldquo;Throw grenade\u0026rdquo;, and in such a situation if you type Z into a textbox, you may throw a grenade when you didn\u0026rsquo;t mean to. Basically, instead of propagating input through a tree, components instead listened for input events directly and as equals. They released some hack to fix it, and now typing in a textbox disables ingame input, but the flaw still remains in principle.\nAsh uses a tree to propagate keyboard events, just like any other events. Moreover, the actual game itself (input to GTA San Andreas) is abstracted as an Ash component, which is a child of root.\nKeyboard events are propagated only to the \u0026ldquo;active\u0026rdquo; child of the node (\u0026ldquo;active\u0026rdquo; is an iterator that is provided to Ash\u0026rsquo;s event dispatcher, another use case of Ash\u0026rsquo;s extra flexible event system). So, when you have a window open, \u0026ldquo;GTA\u0026rdquo; (the Ash component) is not the active child anymore, and it has no reason to ever be aware of the keyboard input.\nAlso note that MTA binds only bind one function to one key. In the future, Ash aims to make possible binds to key combinations or sequences rather than just keys. \u0026ldquo;X then Z then X\u0026rdquo; could be fed as a single bind rather than the poor coder manually implementing a state machine to monitor key sequences. That is a goal for the future.\nBest Foreign Interface Ash is a resource that runs in parallel to the ones that plan to use it. It needs a foreign interface that allows it to communicate with other resources. MTA has a VM common event system, and exported functions, that allow this.\nObserve the code to declare a window with \u0026ldquo;Click me!\u0026rdquo; button (that changes to \u0026ldquo;Clicked\u0026rdquo;) in CEGUI:\nlocal window = guiCreateWindow(X, Y, Width, Height, \u0026quot;Title\u0026quot;, true) local btn = guiCreateButton(X, Y, Width, Height, \u0026quot;Click me!\u0026quot;, true, window) --Change the position of the button for whatever reason guiSetPosition(btn, 200, 200, false) addEventHandler(\u0026quot;onClick\u0026quot;, btn, function() guiSetText(btn, \u0026quot;Clicked\u0026quot;) end)  Here is the same functionality in dxGUI:\nlocal window = dxGUI:dxCreateWindow(X, Y, Width, Height, \u0026quot;Title\u0026quot;, true) local btn = dxGUI:guiCreateButton(X, Y, Width, Height, \u0026quot;Click me!\u0026quot;, true, window) dxGUI:guiSetPosition(btn, 200, 200, false) addEventHandler(\u0026quot;onClick\u0026quot;, btn, function() dxGUI:guiSetText(btn, \u0026quot;Clicked\u0026quot;) end)  Here is the code in Ash:\n--Ash \u0026quot;Panes\u0026quot; do not have titles, a Window is a Pane with a Label local window = Ash.Pane(X, Y, Width, Height) local btn = Ash.Button(X, Y, Width, Height, \u0026quot;Click me!\u0026quot;) window:addChild(btn) btn.x = 200; btn.y = 200; btn.onClick = function() btn.text = \u0026quot;Clicked\u0026quot; end --Or, btn:addEventListener(\u0026quot;onClick, function) if you have multiple listeners  Ash elements behave like tables instead of opaque alien objects from another VM.\nHere is something that is not possible in CEGUI and dxGUI at all:\nwindow:tween({x=100, y=100, alpha=0.2}, 300, null, callback)  tween is a function of AshElement that \u0026ldquo;tweens\u0026rdquo; properties of an AshElement (Very useful for animations, or fading effects, etc). I am also working on forking Ash\u0026rsquo;s tweening functionality into an independent open source project. The code shown here would linearly interpolate the window\u0026rsquo;s X,Y to 100,100 over 300 milliseconds, while slowly making it transparent. Once the animation is complete, the function \u0026ldquo;callback\u0026rdquo; (if provided) will be called.\n Wait, how can you can provide a callback function?\n window is an object that \u0026ldquo;actually\u0026rdquo; exists in another VM. MTA does not support (and indeed, it would seem it would not even be possible) passing of functions from one VM to another. Tables are also copied by value not reference, and the syntax I described here seems impossible. Yet, here in the client VM, we are calling window.tween and window.addChild as functions, or assigning a function to btn.onClick, and even passing functions as parameters to these functions.\nThis magic is accomplished by leveraging Lua metatables and MTA\u0026rsquo;s export system. MTA\u0026rsquo;s export system only allows us to declare a function as exported when a resource is first started. But these functions being passed around are created at runtime! Ash assigns a number to every function/table it sends out to other VMs, and maintains a table of these functions/tables. What the other resource gets is just this unique number. It then creates an object that has its metatables set to call a static exported function (with the unique id as one of the parameters) every time it\u0026rsquo;s properties are changed. Any function calls or assignment operations that use functions or tables do this exact same procedure recursively to wrap those values. Ash also makes sure it deletes any references when the only resource still using them is shut down.\nThis magic was so useful for cross-VM communication in general that I forked it into a separate, independent open source project called bakaGaijin. Ash uses bakaGaijin to provide a seamless foreign interface.\nShaders, affine transforms, 3D GUI, and more Ash\u0026rsquo;s rendering process is basically a DFS of every component instance in the display tree, and each of their \u0026ldquo;render\u0026rdquo; method being called. (I am working on caching the display so that render is only called if a child bubbles up the need for an update). DFS happens because the \u0026ldquo;render\u0026rdquo; function of a component usually recursively calls the \u0026ldquo;render\u0026rdquo; function of all it\u0026rsquo;s children.\nIf a component doesn\u0026rsquo;t implement its own render method, then Theme.ComponentName is considered to be the rendering function. Yes, you heard that right. The entire theme system that I am so proud of can be entirely ignored by the implementation of a component if it chooses to do so. Not just that, the implementation may also choose not to recursively call \u0026ldquo;render\u0026rdquo; for all its children, so the rendering process may NOT be a DFS. A component chooses how the render-call-subtree below it looks.\nIn fact, this \u0026ldquo;custom rendering function\u0026rdquo; is how Tabbed menus are implemented in Ash. Instead of rendering all its children, a TabMenu only calls the render function of the currently active window.\nThis also means, that Ash\u0026rsquo;s \u0026ldquo;GUI\u0026rdquo; is not constrained to 2D, or displaying at all. You could decide that a label should be represented as 3d textures being rendered in game. This means we can even reuse Ash\u0026rsquo;s system for some sort of UI where the player is required to walk up to buttons to select them, etc. I will have to add a safety net here so that untrusted components can be run, but it looks promising.\nThe rendering function of a component also gets INHERITED CONTEXT as a parameter, which it must pass to its children after modifications. Inherited context means that the rendering of the children depends on the parents. Alphas are multiplied by parent alphas (as you would expect), X and Y coordinates are added up (So all coordinates are relative). Why stop at alpha? It also inherits all other color transformations. You can tint elements, and all their children would get tinted. Color transformations are accomplished by keeping 9x9 matrices, and multiplying them to perform affine transformations.\n \\begin{bmatrix} rrf \u0026 grf \u0026 brf \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ rgf \u0026 ggf \u0026 bgf \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ rbf \u0026 gbf \u0026 bbf \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 aaf \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ rcf \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 gcf \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 bcf \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 acf \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \\\\ rtf \u0026 gtf \u0026 btf \u0026 atf \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix}  where $r\u0026rsquo; = red\\times{}rrf + green\\times{}rgf + blue\\times{}rbf + blend\\times{}rcf + rtf$\nOf course, the actual matrices are sparse so we store 18 values per component, not 81.\nMTA also exposes methods to use SDL shaders with directX. I did not understand shaders when I made most of Ash, so I did not implement them as inherited context. Over the summer I have studied shaders and future versions of Ash will keep shaders as inherited context, making these color transformations obsolete.\nAsh also keeps \u0026ldquo;scale\u0026rdquo; as an inherited context which is multiplied like alpha. This means entire windows can be \u0026ldquo;minimized\u0026rdquo; by literally making them smaller. Scaling like this is not available in other frameworks.\nSamples All videos on this page are without audio.\nHere is a video contrasting CEGUI with Ash. It shows off how Ash benefits from having stateful renderers, and some neat Ash features such as tweening. The buttons get animated when the mouse is over them.\n Here we can see that TextBoxes and keyboard input are fully functional in Ash. Note that the keyboard input would not get into the TextBox were it not selected. We can also see what the Default Theme\u0026rsquo;s TabbedPane implementation looks like. Unlike CEGUI, tabs can take a fixed width, or take up as much space as possible. The default theme allots space based on how long the title of the tab is (Similar to Google Chrome when its full)\n Here we see how the scale parameter may be used. We see more tweening, this time of position, scale and even alpha. We observe the effects of the \u0026ldquo;inherited context\u0026rdquo; an element gets as scaling, alpha and translation are propagated down to the children.\n Ash is closed source (and not at all mature) at this time, but I will make it open source eventually. You\u0026rsquo;re going to have to wait.\n"
        })
    
        searchIndex.addDoc({
        	"title" : "Hewlett Packard Enterprise",
        	"tags" : "Javascript Java Bot",
        	"content" : "My summer internship at HP resulted in the creation of a clever and simple system to tackle a complex problem (Under construction)\n\n"
        })
    
        searchIndex.addDoc({
        	"title" : "Procedural Generation",
        	"tags" : "",
        	"content" : "Procedural level and art generation for tiled video games using noise, upscaling, L-systems and cellular automata.\n See it in action here.\nSource code: here.\n"
        })
    
        searchIndex.addDoc({
        	"title" : "bakaGaijin",
        	"tags" : "",
        	"content" : "bakaGaijin is an open source (MIT License) project that emerged from the (larger and closed source) Ash project.\nIt aims to provide seamless cross resource communication across Lua virtual machines in MTA.\n\nSome Background  Multitheft Auto (MTA) is an open source modification of Rockstar\u0026rsquo;s very successful (and old) game Grand Theft Auto: San Andreas. It adds support for multiplayer (GTA:SA is originally single player only), and lets the server hosting the game change every aspect of the game at run time through Lua scripts that interact with hooks provided by the engine.\n For modularity, it encourages developers to split and decouple their scripts as \u0026ldquo;resources\u0026rdquo;. A resource has one or more script files that run in sequence on one Lua Virtual Machine. There is exactly one VM per resource, and as such resource A does not suffer from memory leaks or crashes occurring in a resource B.\nAs two different resources sit on different VMs, the only way for them to communicate is through MTA (i.e. the C interface exposed by MTA). MTA provides few approaches for any resources to communicate with each other.\nBefore bakaGaijin  MTA has an element tree that is synched for every VM. Any event that is triggered on an element in one VM is also triggered in all other VMs. Elements are objects that are implemented by the C code, and can thus be transferred across VMs as opaque objects.\n Elements can also contain properties (called \u0026ldquo;element data\u0026rdquo;). These are string keys mapped to tables or primitive data types. Tables stored in this way are stripped of any non-storable keys/values. Functions/Threads cannot be stored as element data, and the keys cannot be anything other than strings. There have also been some bugs in the past where element data was not behaving properly. As such, elements and their behavior are coded in C and do not benefit from Lua\u0026rsquo;s principles or from Lua\u0026rsquo;s well known reliability. Tables \u0026ldquo;fetched\u0026rdquo; from element data are copied by value when sent to the VM, and thus any changes made to them do not reflect on the element data until they are manually copied back. This leads to thread safety issues that need to be stepped around. MTA has an event system for these elements, and these elements form a tree that the event is propagated through.\n  Thus, element data and event handlers on elements are one way of communicating with other resources.\n MTA offers the concept of \u0026ldquo;exported\u0026rdquo; functions. A resource may declare (in its configuration files) that it is exporting certain global functions. Other resources are then allowed to call such exported functions through the syntax of exports.remoteResourceName.functionName(exports.remoteResourceName, ...).\n This changes the signature of the originally exported function, as it has an additional self parameter now. The function must be declared as exported statically before the resource is loaded. The function must be global and named. Anonymous functions and local functions aren\u0026rsquo;t allowed. The configuration is stored in an XML file. Nobody wants to touch the XML files. The parameters and return values are still stripped of any values the C interface cannot comprehend (functions, threads, tables values/keys that are functions/threads) Any tables that are returned or passed as parameters are still copied by value.  The third option is file or database operations. Not a feasible solution.\n  The Problem While usually this decoupling of resources is not a problem as resources rarely talk to each other, but there are many valid use cases where two resources need to be coupled more tightly (e.g. dxGUI, Ash, DataBase management, Debugging systems).\nMTA\u0026rsquo;s inability to pass abstract/contextual datatypes means that the developers of such resources need to sidestep these problems, usually through opaque handles and a bunch of functions to change their state.\nThe Solution bakaGaijin is a framework where your resource can expose any value it wants during runtime. These values do not have to be global, or even currently referenced. This can be done in one simple line of code as bakaGaijin.SomeLabel = value\nbakaGaijin also provides a way to get such exposed values from other resources. This is also done easily as foreignValue = bakaGaijin(\u0026quot;RemoteResourceName\u0026quot;).SomeLabel\nThis may not seem complicated, but consider a case like this:\n--At resource1 bakaGaijin.ABC = {x=0} --Then, at resource2 local ABC = bakaGaijin(\u0026quot;resource1\u0026quot;).ABC --Then, at resource3 local ABC = bakaGaijin(\u0026quot;resource1\u0026quot;).ABC --Then at resource1 bakaGaijin.ABC = nil --The table is now not referenced anywhere in resource1, but it is still alive and will not be deleted. --Then, at resource2 ABC.x = ABC.x+1; --Then, at resource3 print(\u0026quot;ABC.x is \u0026quot;..ABC.x) --ABC.x is 1 ABC = nil --Only resource2 has a reference to ABC at this point --Then, at resource2 ABC = nil --ABC is now a candidate for deletion, and resource1 will delete it eventually.  Also, let me tell you how easy it is to set up bakaGaijin. It only uses one exported function, and this function is a multiplexer for all communications. All you need to declare is one statically exported function called bakaGaijin_export\nABC in resource3 and resource2 is also obviously not actual references to the table in resource1 (The C interface is incapable of that). The behavior of the handler is emulated using clever metaprogramming. Lua uses metatables for this, which is similar to \u0026ldquo;object prototypes\u0026rdquo; in other languages.\nSo bakaGaijin has been a leaning experience in the topics of API design, metaprogramming, memory management, multi-threading, and design in general.\nIf the data exchanged in these operations is immutable and serializable, then they are sent as they are without any subsequent performance loss. However, if they are tables, closures, or such mutable types then they are automatically \u0026ldquo;prepared\u0026rdquo; so that they can be sent across safely. This preparation is done by:\n Storing them in an internal table on the host resource (The one that sent them) Sending a handle of this object to the client resource (The one that requested it) Generating a pseudo-object client side that behaves just like the actual object that was sent. This object would communicate with the host resource whenever a get/set/call is performed on it.   Exported functions are the most performant way of introducing the concept of callback functions (but this requires preparation). The event system is a little slower, but does not require any preparation before runtime. bakaGaijin uses an exported function to communicate with other resources, but most of the code is agnostic of this and it can be easily changed to use the event system instead.\nbakaGaijin also has it\u0026rsquo;s own \u0026ldquo;meta garbage collector\u0026rdquo; (I don\u0026rsquo;t know what else to call it) that manages the deallocation of values no longer accessible to other resources via bakaGaijin. So you do not need to worry about any memory leaks.\nIf you just want to use bakaGaijin for your own project, then check out \u0026ldquo;Test1\u0026rdquo; and \u0026ldquo;Test2\u0026rdquo; (to be run in parallel) on GitHub. The source code is heavily commented and reading it cursively should be enough to understand how to use it.\nThe rest of this page explains how it works.\nHow it works Let\u0026rsquo;s see how bakaGaijin does its magic.\nSome Vocabulary  bakaGaijin  Either the script itself, or an instance of the script running on a particular VM. An instance of bakaGaijin.lua (or its minified version) must be running on every VM that is using bakaGaijin to communicate.\n expose access  I will make a distinction between the term \u0026ldquo;exposed\u0026rdquo; and \u0026ldquo;accessible\u0026rdquo;.\nConsider this:\n--//resource1 local x = {y=true} bakaGaijin.x = x --//then at resource2 local x = bakaGaijin(\u0026quot;resource1\u0026quot;).x --//then at resource1 bakaGaijin.x = nil --//x is not longer EXPOSED (A resource cannot use bakaGaijin(\u0026quot;resource1\u0026quot;).x to access x) --//then at resource2 --//x from resource1 is still ACCESSIBLE to resource2, as it already got a reference earlier. print x.y --//true x.y = false --//but it is not EXPOSED print bakaGaijin(\u0026quot;resource1\u0026quot;).x --//nil  Accessible is when a resource can read/write an original object exposed earlier.\nExposed is when a resource can get the reference to the original object from the host resource using bakaGaijin.\n original object  If a resource exposes a value (string, function, table, number etc) using bakaGaijin, that value is the original object.\nIn bakaGaijin.label = x, x is the original object. Only really makes sense when x is a candidate for tokenization.\n token_id  Each original object is allotted a token_id when a PT is constructed for it for the first time. There is a guarantee that no two original objects will have the same token_id at the same time. The token_id of an original object does not change as long as bakaGaijin is keeping it accessible.\n candidate, candidate for tokenization  A value that has a type that cannot be transferred across resources without information loss.\nA value is NOT a candidate for tokenization if it is immutable and serializable.\nA candidate is of type table or function. Threads are also candidates, but not supported by bakaGaijin at the time of writing. All values of type function or table are candidates UNLESS they are an AT\n My apologies, but \u0026ldquo;token\u0026rdquo; or \u0026ldquo;tokenization\u0026rdquo; in bakaGaijin has nothing to do with tokenization in compilers. \u0026ldquo;Serialization\u0026rdquo; would be a better term, but \u0026ldquo;tokenization\u0026rdquo; stuck somehow\n  host, host resource  Resource that contains the original object.\n client, client resource  Resource that wishes to use an original object that it does not contain.\n primitive  Any value of type boolean, number, string, nil or userdata\n GC  Garbage collector. \u0026ldquo;GCed\u0026rdquo; means garbage collected.\nHere is a joke: \u0026gt;If Java had true garbage collection it would collect itself.\n AT, Active Token  A value present on the client resource. Client resource uses an AT as a handler/controller to interact with original object on the host resource. An AT is always interned\n interned, interning  A term borrowed from Lua\u0026rsquo;s string interner. May be a misnomer.\nIt basically means that active tokens are cached and reused, and there is a guarantee that one original object will only corresponding to one or zero AT in a given resource.\nActive tokens are interned, which means that if a a resource receives the same passive token again, it reuses the active token already made for it.\n PT, passive token\n Can be transferred across resources without information loss. Used to represent an original object Used as an intermediate representation of an original object when two resources are communicating via bakaGaijin. AT is constructed from a PT at the client resource. Contains the token_id of the original object it represents, and a non-guessable stamp. Even though token_id can be used to uniquely identify an original object in a host resource, stamp must also match to ensure data integrity. A table is considered to be a PT if it has \u0026quot;__gaijin_res\u0026quot; as a key to a truthy value. PTs are also interned like AT, and there is a guarantee that there cannot be more than one PT for the same original object in the host resource.\n  elem, element\n  primitive, AT or candidate\n gaijin  Some bakaGaijin concepts  bakaGaijin_export  bakaGaijin_export is a global constant of type function, which is exposed to other resources via MTA\u0026rsquo;s export system. This function is the only way for bakaGaijin to gets information from another resource. It can perform various duties depending on the first argument it gets, and is essentially a multiplexer.\nbakaGaijin_export is usually called by OTHER RESOURCES, not the host resource that defined it.\nfunction bakaGaijin_export(typ, tokenid, stamp, ...) local sourceResource = getResourceName( sourceResource ) --sourceResource is the remote resource that called bakaGaijin_export --Performs various operations depending on the first parameter, --which is an opcode of sorts. if typ==\u0026quot;s2t\u0026quot; then return getPTokenFromElem(--[[Omitted]]) elseif typ==\u0026quot;free\u0026quot; then return bakaGC() end --Asserts some checks to ensure integrity if not gaijinPool[tokenid] or stamp ~= stampLookup[tokenid] then return nil end --Operations for opcodes that required the checks above if typ==\u0026quot;get\u0026quot; then return getProp(sourceResource, tokenid, ...) elseif typ==\u0026quot;set\u0026quot; then return setProp(sourceResource, tokenid, ...) --Omitted: Long if-else ladder. else error(\u0026quot;bakaGaijin_export called incorrectly by \u0026quot;..sourceResource) end end   Multimap  I will not explain how it does it, but multimap.new(N) creates a table that maps N keys to a value. It mainly just provides syntactical sugar, and the same functionality can be accomplished using trees.\nThe implementation is flawed and will cause memory leaks, so do not reuse it. However, the way bakaGaijin uses it ensures that no memory leaks occur.\nThe main (and only) reason its used is because the resulting table is null safe and the syntax is convenient. (So we can pretend that Lua has ?. operator like Groovy)\nAlso, it stores the values in a weak table, so they fall off if not referenced elsewhere.\nlocal mm = multimap.new(2) mm[1][2] = \u0026quot;Value\u0026quot; --Does not complain about mm[1] being null assert(mm[\u0026quot;I don't exist\u0026quot;][1] == nil) --no error assert(mm[1][2] == \u0026quot;Value\u0026quot;) --no error  If you want to know how it works, it uses recursion and metatables. Just search for the this definition in the source code:\nlocal multimap = {}   gaijinPool  A table at the host resource that maps token_id to original object.\n stampLookup  A table at the host resource that maps token_id to a stamp value. This stamp value is set when a PT is constructed for the original object.\nNot necessarily a time stamp, but used to ensure that a newly exposed original object with the same token_id as an older expired one is not misinterpreted as the older one by a different resource.\nAlso acts as a \u0026ldquo;password\u0026rdquo; as other resources can\u0026rsquo;t fake the stamp unless they actually got the PT from somewhere. (token_id may be guessable, but stamp is not)\n tokenLookup\nThis table serves two purposes.\n At the client resource, maps an AT to the PT used to construct it. At the host resource, maps a candidate to the PT constructed for it (if any).   This is a key-weak table and values fall off if the AT/candidate is no longer referenced anywhere.\n ATinterner  This is a multimap used to ensure that ATs are interned. It maps (hostResourceName, token_id) to an AT\nThe AT is stored weakly, and does not prevent it from being GCed.\n ATmeta  A metatable that lets ATs representing a table behave as if they are the table. Implementation is in the source code. Search for the string below to find its definition.\n`--Generate metatable for an AToken being made form a PToken`   getPTokenFromElem  A function that takes a value as argument, and returns something that is guaranteed to be transferable across resources without information loss.\nThe returned value is also guaranteed to be able to uniquely identify the argument value.\nActs as a filter for all values going from a host resource to a client resource.\nIf argument is not a candidate, returns it as it is.\nIf it\u0026rsquo;s an active token, then returns the passive token associated with it (from tokenLookup).\nIf it is a candidate, then returns a PT representing it.\n If a PT for the candidate exists in tokenLookup, then returns that cached value If the PT doesn\u0026rsquo;t exist, then constructs one, adds it to tokenLookup, and returns it.  Look at appendix below for implementation details.\n getElemFromPToken  Acts as a filter for all values coming from a host resource to a client resource.\nTakes one argument.\nIf it received a valid passive token:\n fetches and returns associated object (if this resource is the host for the PT) or reuses an AT if it exists in ATinterner (if this resource is a client for the PT) or constructs an AT (and updates ATinterner and ATcache) (if this resource is a client for the PT)  Active tokens and non-candidates are returned without any changes.\nLook at appendix below for implementation details.\n getProp(client, token_id, key) setProp(client, tokenid, key, value) callFun(client, tokenid, \u0026hellip;)  Functions that are called on the host when a client attempts to get/set a value on an AT (or call an AT) that represents an original object in the host resource.\nThese are actually called by bakaGaijin_export, which multiplexes these (and other functions) using opcodes.\n pairs, ipairs  ipairs and pairs are iterators used in Lua to enumerate the keys and values of a table.\nIn Lua 5.2, the __pairs and __ipairs metamethods were added, allowing us to define how pairs and ipairs should behave over a table.\nWe are working in Lua 5.1 and do not have this luxury.\nipairs and pairs do not work properly over an AT. To make ATs behave more like tables, ipairs and pairs as global functions have been overridden (decorated) with versions that can deal with ATs.\nSpecifically, when the new ipairs or pairs encounters an AT, instead of iterating over it, it calls bakaGaijin_export on the host resource with the opcode pairs or ipairs. The host resource then constructs a table of PTs and returns that, which is what pairs/ipairs iterates over.\nThe original versions of pairs and ipairs are still available as raw_pairs and raw_ipairs.\nThis can be observed in the source code if you search for the string\n----OVERRIDES-----  The functions called by bakaGaijin_export when it receives pairs or ipairs as an opcode are local function pairsByID(tokenid) and local function ipairsByID(tokenid), which can be searched for in the source.\n Exposed variables  bakaGaijin uses metatables to provide its syntax of bakaGaijin.label and bakaGaijin(\u0026quot;resource\u0026quot;).label\nbakaGaijin itself has its metatable set to bakaGijin_meta\nlocal bakaGaijin_meta = { __call = function(t, rec) local proxy = {res_name = rec} setmetatable(proxy, recmeta) return proxy end }  So, val = bakaGaijin.label and bakaGaijin.label = val actually do use bakaGaijin as a raw table. label must not be a candidate value, care must be taken regarding this by the user. I recommend using only string or number keys, and future versions may only allow string/number keys.\nIn the source code you will find a table named nameCache. This is actually bakaGaijin.\nLater in the code: bakaGaijin = nameCache\nCalling bakaGaijin as a function with argument rec returns an object with its key res_name set to rec and its metatable set to recmeta\nlocal recmeta = { __index = function(t, index) return getElemFromPToken(exports[t.res_name]:bakaGaijin_export(\u0026quot;s2t\u0026quot;, index)) end, __newindex = function() error(\u0026quot;You cannot set data for another resource.\u0026quot;, 2) end }  Thus, if this object returned by bakaGaijin(\u0026ldquo;someResource\u0026rdquo;) is indexed, then it actually calls bakaGaijin_export on the host resource with the opcode s2t and the label key as an argument. The value returned by bakaGaijin_export is filtered using getElemFromPToken and returned to the user.\nSnippet from bakaGaijin_export:\nfunction bakaGaijin_export(typ, tokenid, stamp, ...) --IN THIS CASE, TOKENID IS NOT ACTUALLY TOKENID, IT IS THE KEY THAT WAS REQUESTED local sourceResource = getResourceName( sourceResource ) if typ==\u0026quot;s2t\u0026quot; then return getPTokenFromElem(nameCache[tokenid]) --omitted: elseif ladder end --omitted: rest of the function end  s2t stands for \u0026ldquo;String to token\u0026rdquo;, which resolves a string to a passive token.\nFinally an explanation Ok, don\u0026rsquo;t worry if you didn\u0026rsquo;t understand all those terms, just keep visiting the definitions as you hear them in places.\nI expect you to know how MTA exported functions are called, how garbage collection works, and basic Lua. Knowing metatables in Lua also helps.\nKnow that bakaGaijin(\u0026ldquo;remoteResourceName\u0026rdquo;) returns a \u0026ldquo;special\u0026rdquo; table (a table with something called a metatable) that, when indexed calls exports[\u0026quot;remoteResourceName\u0026quot;]:bakaGaijin_export(\u0026quot;get\u0026quot;) and returns the value it gets after running getElemFromPT on it.\n getElemFromPT?\n getElemFromPT is a function that acts as a \u0026ldquo;filter\u0026rdquo; of sorts. Everything that is coming to this resource from another resource goes through this filter first. Most items go through unaffected, but PTs are converted into ATs or their respective original objects.\n PT? AT? original objects?\n Original object is what the other resource \u0026ldquo;tried\u0026rdquo; to send to you, but could not possibly have (functions, for example)\nSo we convert it into a PT instead, and the PT gets sent without any problems.\nOnce we get the PT, we convert it into an AT, which is another \u0026ldquo;special table\u0026rdquo; (or sometimes a function) that updates the values of the original object whenever its own values are changed, or asks the other resource to call its own function when the AT is called.\nWe also have a getPTfromElem function that filters everything that goes out, converting it into a PT if needed.\nEDIT: Here is a wikipedia article discussing the topic (Vocabulary is different from mine)\nHere is a diagram I made that attempts to explain PTs and ATs\nparticipant Host\rparticipant getPTfromElem\rparticipant MTA\rparticipant getElemFromPT\rparticipant Client\rnote over Host, getPTfromElem: Host and getPTfromElem are\\nin the virtual machine to\\nwhich the object is native.\rnote over Client, getElemFromPT: Client and getElemFromPT are\\nin the virtual machine which\\nwants to access the object.\rnote over MTA: MTA has the C interface\\nthat connects the\\ntwo virtual machines.\rnote over Host, Client: Values that are immutable and serializable (e.g numbers and strings) are sent across as they are\rHost-getPTfromElem: \"Hello\" : string\rgetPTfromElem-MTA: \"Hello\" : string\rMTA-getElemFromPT: \"Hello\" : string\rgetElemFromPT-Client: \"Hello\" : string\rnote over Host, Client: But non-immutable or non-serializable data is sent through a stub.\rHost-getPTfromElem: f : function\rgetPTfromElem-MTA: PT(f) : {hostid, obj_id}\rMTA-getElemFromPT: PT(f) : {hostid, obj_id}\rgetElemFromPT-Client: AT(f) : function\r \u0026lt;function\u0026gt; f is the original object.\nThe green star is the process of converting an original object to a PT. The blue star is the process of converting a PT to an AT.\nPT(f) is implemented as this:\n{ __gaijin_id = XYZ, --//Some number to uniquely identify function f __gaijin_res = Host_Resource_Name, --// (__gaijin_res, _gaijin_id) can together be used to uniquely identify an original object. __gaijin_stamp = PQR, --//Some number to ensure integrity __gaijin_fun = true --//Tells the client resource that the original object is a function }  AT(f) is implemented as this:\nfunction(...) return getElemFromPT( exports[PT.__gaijin_res]:bakaGaijin_export( \u0026quot;call\u0026quot;, PT.__gaijin_id, PT.__gaijin_stamp, ...) ); end  An AT for a table is a bit more complicated as it uses metatables to fire callbacks for get and set operations.\nbakaGaijin_export is the only exported function and can do a lot of tasks for us depending on the first argument it gets. For example, in this case, \u0026quot;call\u0026quot; told it to call a function and return the value. Needless to say, the function parameters and return values also pass through getElemFromPT and getPTfromElem\nAlso note that resources can send ATs to each other. The AT would get converted to the original PT it was calculated from, and then sent to other resources. The other resources will convert it into ATs again in their own VMs. Unless the original object belonged to one of the resources\u0026hellip; in that case the resource would realize that the PT represents an object in its own machine and getElemFromPT(PT(f)) would be the original object itself.\nMeta Garbage Collection, Virtual Virtual Machine Networks and Hacks  Subscriptions  I have already highlighted before, the need for a \u0026ldquo;meta garbage collector\u0026rdquo; in bakaGaijin.\nSince references are still alive and may be accessible when they are no longer exposed, we need to have a mechanism to delete them when no resource at all has access to them, and keep them alive otherwise.\n\u0026hellip;ok, I can\u0026rsquo;t type anymore. This is very tiring.\nLess reference manual, more short story now.\nShort story:\nbakaGaijin has a \u0026ldquo;sub\u0026rdquo; opcode that a remote resource calls when it has subscribed to a particular original object.\nThis subscription is stored in an internal table called ownLookup\nownLookup is a multitable that maps (remoteResourceName, tokenID) to TRUE or NIL. TRUE meaning that remoteResource has access to original object represented by tokenID, and NIL meaning otherwise.\nThe subscription call is fired by the remote resource whenever getElemFromPT gets a valid PT it didn\u0026rsquo;t already have an AT for. Similarly, there is an \u0026ldquo;unsub\u0026rdquo; opcode that unsubscribes a resource to an original object. This is called whenever the remote resource cannot access an AT anymore.\nWhenever the host resource gets an unsub for an original object, it checks if there are still any subscribers left.\nIf there are no more subscribers after an unsub call (no more resources that can access the original object), then the original object is removed from gaijinPool, tokenLookup, stampLookup and ownLookup. The PT is no more, and the original object will get GCed unless the host resource itself is using it.\nLua 5.2 has __on_garbage_collect metamethod that works as a destructor, and would have been used to fire unsub calls when an AT is GCed.\nHowever, we are on Lua 5.1, and do not have such a luxury. There is a lot more to explain.\n How do you fire unsub calls?\n This is hacky, do not try this at home.\nYou already know ATinterner, it maps a token_id to an AT weakly. If the AT is GCed, then this table will not contain it anymore.\nWe also have a table called ATcache (I neglected to mention it before) that maps token_id to a TRUTHY value or NIL. This table is not weak.\nATcache is a \u0026ldquo;shadow\u0026rdquo; of ATinterner. For every AT that is put in ATinterner, a truthy value is also put in ATcache.\nWe also have a timer that calls a function updateATC every ATC_WAIT milliseconds (Every minute by default).\nThis function\u0026hellip; wait for it\u0026hellip;.\nCHECKS FOR KEYS THAT ARE TRUTHY ON ATcache AND FALSY ON ATinterner.\nNow before you throw tomatoes at me, let me tell you that this was the only way to do it. Lua 5.1 does not have any callbacks that we can fire on garbage collection (implemented in pure Lua). It is not very inefficient, don\u0026rsquo;t worry.\nAnyway, if ATcache has a value that\u0026rsquo;s truthy, and ATinterner has it as nil, then ATinterner dropped the value, which means it was garbage collected. This results in an unsub call.\nNow, here emerges a new problem:\nThe Lua garbage collector only kicks in if the Virtual Machine is actually low on memory.\nNow that we have created this\u0026hellip; large \u0026ldquo;Virtual Virtual Machine\u0026rdquo; Network where references are shared among virtual machines\u0026hellip; the garbage collector should not be selfish and only kick in when its own Virtual Machine is starving.\nIf the client resource is under no stress, it will not fire unsub signals regardless of whether or not the host resource is under stress.\nbakaGaijin has two strategies to handle this.\nOne is the most obvious: For every COLLECTOR_WAITS calls to updateATC, collect_garbage is called once forcing the client resource to clean up its mess. (Every 10 minutes by default)\nlocal LOAD_GAIN_TOLERANCE = 1.4 --If a resource keeps locking lots of objects and actually uses them, it's allowance is increased. --LOAD_GAIN_TOLERANCE tells bakaGaijin how much to increase the allowance each time it's exceeded. --A value of 1.4 means allowance will increase by 40%. This makes the GC elastic and dynamic. local LOAD_MIN = 100 --The minimum number of items a resource is allowed to lock before it's asked to check it's actual usage and send unsub messages local COLLECTOR_WAITS = 10 --Number of bakaGaijin's GC's sweeps before the Lua GC is invoked local ATC_TIME = 60000 --Milliseconds between each \u0026quot;sweep\u0026quot; of bakaGaijin's GC  The second solution is much more elegant, and makes the first one unneeded (but we keep it anyway).\nThere is also a table called loads which maps a client resource to the number of original objects (belonging to the host resource) it is subscribed to.\nThere is another table called loadsShadow which maps a client resource to the \u0026ldquo;last known number of objects actually used\u0026rdquo; by the client resource.\nThere is a LOAD_MIN threshold the host has. Clients are not bothered until they cross this threshold.\nOnce they cross this threshold, bakaGaijin_export is called on the client with the opcode free. This forces the client to call its garbage collector, and then call updateATC. updateATC then fires unsub messages.\nThese unsub messages reach the host, which gladly accepts them. It then REEVALUATES the client resource\u0026rsquo;s usage (Any objects not being used have been unsubbed at this point, so all subbed objects are being used). Since at this point all the objects are actually being used, loadsShadow\u0026rsquo;s value is set to load\u0026rsquo;s value loadsShadow[res] = loads[res] If there are lots of subbed objects, then the host realizes the client\u0026rsquo;s need for more memory and a new threshold is set. New threshold is set as loadsShadow[res] * LOAD_GAIN_TOLERANCE(1.4 by default)\nIf there are too few subs, and the allowance the client previously had is not justified anymore, then the tolerance is set to a lower level. Again, using the same formula loadsShadow[res] * LOAD_GAIN_TOLERANCE\nThe threshold can never be lower than LOAD_MIN (100 by default), which means a client will never be bothered if it keeps less than 100 subscriptions.\nThat\u0026rsquo;s all folks\u0026hellip; I don\u0026rsquo;t know if you understood any of this stuff but I had a duty to document this project.\nIf you still insist on understanding its workings and this page didn\u0026rsquo;t answer all your questions, then shoot me a mail. :-]\n"
        })
    
        searchIndex.addDoc({
        	"title" : "FOSSEE",
        	"tags" : "Testing Bash Scilab MATLAB C Open Source VM",
        	"content" : "I had the wonderful opportunity to intern at IIT Bombay to help develop the Image Processing Toolbox for Scilab, a free software developed by French company Scilab Enterprises. I got this opportunity as a member of FOSSEE (Free Open Source Software For Education), an initiative by IIT Bombay to make available open source equivalents of proprietary academic software.\n\nI had worked with a team of 6-7 interns from different colleges across India. We worked under professor Kannan M Moudgalya, and my immidiate mentor miss Shamika.\nMy duties were primarily related to interfacing C with Scilab to call native OpenCV functions for Scilab operations, to ensure that the exposed functions follow the project guidelines regarding syntax and signatures (This involved a lot of code refactoring and migration, for which I was required to build automatic tools), and to build tools to run unit tests on these functions.\nI will describe my experiences (and the software I wrote) in more detail later, this page is under construction.\n"
        })
    
    var resultCards = document.getElementsByClassName("post")
	var sortCmp = function (a, b) { return b.score - a.score; }
	var swapCards = function(a, b) {
		if(a == b) return
		var temp = a.innerHTML
		a.innerHTML = b.innerHTML
		b.innerHTML = temp
		temp = a.id
		a.id = b.id
		b.id = temp
	}
	var searchDocs = function() {
		var query = document.getElementById("searchbar").value
		var results = searchIndex.search(query, {
		    fields: {
		        tags: {
		            boost: 2,
		            expand: false
		        },
		        title: {boost: 3},
		        content : {boost : 1}
		    },
		    expand: true
		})
		console.log(results)
		results.sort(sortCmp)
		for(var i=0; i<results.length; i++) {
			swapCards(resultCards[i], document.getElementById(results[i].ref))
		}
	}
	</script>

        </div>
        
      </div>  
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a target="_blank" href="https://www.linkedin.com/in/anirudh-katoch-b24685127/" class="iconfont icon-linkedin" title="linkedin"></a>
      <a target="_blank" href="http://www.github.com/luca-spopo" class="iconfont icon-github" title="github"></a>
  <a href="http://luca-spopo.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">

  
  <span class="copyright-year">
    &copy; 
    2017
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Anirudh Katoch</span><br>
      <a href="mailto:katoch.anirudh@gmail.com">katoch.anirudh@gmail.com</a><br>
      <a href="/pay/" style="font-size: 12px">Click here to send me money.</a>
  </span>
  <span>
    Credits for the logos go to <a color=#c05b4d target="_blank" href="https://dribbble.com/shots/2055585-Chiyo-Dad-Emojis">Gabe from Dribble</a>.
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script type="text/javascript">{
  var logos = document.getElementsByClassName("logoImage")
  logos[0].src = logosource
  logos[1].src = logosource
}</script>
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=2.6.5"></script>





</body>
</html>
